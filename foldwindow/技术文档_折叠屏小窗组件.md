# 折叠屏/Pad 小窗组件技术文档

## 1. 组件定位与目标

该组件用于**大屏（Pad/折叠屏）场景**下的主内容展示，支持：
- 默认**全屏显示**
- 点击 `MINI` 切换为 **16:9 竖向小窗**
- 小窗可自由拖拽
- 点击 `FULL` 恢复全屏
- 左侧菜单栏可动画展开，并**挤压右侧内容**（非覆盖）
- 菜单宽度可拖拽微调（默认 30%，范围 25%~35%）
- 小窗状态自动圆角，使用系统硬件裁剪，避免额外绘制开销

## 2. 目录结构

```
foldwindow/
├─ build.gradle
├─ proguard-rules.pro
└─ src/main/
   ├─ AndroidManifest.xml
   └─ java/com/example/foldwindow/
      └─ FoldPadWindowLayout.java
```

## 3. 架构与职责划分

组件以一个自定义 `FrameLayout` 为核心，内部划分为三层：

1. **内容宿主层（mContentHost）**
   - 承载顶部按钮栏与主内容
   - 负责全屏/小窗切换、拖拽位置
   - 小窗状态下开启圆角裁剪

2. **内容容器层（mContentContainer）**
   - 外部业务内容放入这里
   - 支持 `setContentView()` 动态替换

3. **侧边栏层（mSidebar）**
   - 位于左侧
   - 展开时挤压右侧内容
   - 右侧的拖拽条负责调整宽度比例

### 结构示意

```
FoldPadWindowLayout
├─ mContentHost
│  ├─ mTopBar (按钮栏：MENU / MINI / FULL)
│  └─ mContentContainer (业务内容)
└─ mSidebar (左侧菜单)
```

## 4. 关键状态与行为

### 4.1 状态机

- `全屏状态`
  - mContentHost 宽高 = 屏幕宽高
  - menu 可打开，侧边栏挤压内容

- `小窗状态`
  - mContentHost 变为 16:9 竖向小窗
  - 自动居中
  - 自动隐藏 MENU
  - 自动收起侧边栏
  - 启用圆角裁剪

### 4.2 侧边栏“挤压”效果

**原则：不覆盖内容，而是改变内容宽度**

```
内容宽度 = 屏幕宽度 - 菜单宽度
内容 X = 菜单宽度
```

实现方式：
- `applySidebarEffect()` 动态调整 `mContentHost` 的宽高与 X 坐标
- 使用 `ValueAnimator` 平滑动画
- 动画过程中 `requestLayout()` 保证文本/布局居中同步更新

### 4.3 小窗拖拽

- 监听 `mContentHost` 的触摸事件
- 仅在小窗状态下可拖拽
- 通过 `getMiniBounds()` 限制拖拽范围，防止超出屏幕

### 4.4 圆角性能优化

小窗圆角采用：
- `ViewOutlineProvider`
- `clipToOutline(true)`

优点：
- 硬件裁剪，成本低
- 无需额外 Canvas 绘制或 Xfermode

## 5. 核心实现说明

### 5.1 全屏 ↔ 小窗切换

- 计算目标矩形：`getTargetMiniRect()` / `getTargetFullRect()`
- `ValueAnimator` 逐帧改变 `mContentHost` 宽高与位置

### 5.2 菜单展开与收起

- 菜单使用 `translationX` 从左向右滑出
- 同时调用 `applySidebarEffect()` 对内容区域做挤压动画

### 5.3 菜单宽度拖拽

- 监听菜单右侧拖拽条 `mSidebarHandle`
- 根据拖拽位置计算宽度百分比
- 将宽度限制在 25% ~ 35% 之间

## 6. 使用方式

### 6.1 依赖方式

在 `settings.gradle` 中引入：
```
include ':foldwindow'
```

在 `app/build.gradle` 中引用：
```
implementation project(':foldwindow')
```

### 6.2 XML 引入

```xml
<com.example.foldwindow.FoldPadWindowLayout
    android:id="@+id/fold_pad_window"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

### 6.3 Java 使用

```java
FoldPadWindowLayout layout = findViewById(R.id.fold_pad_window);
layout.setContentView(yourContentView);
layout.setSidebarContent(yourMenuView);
```

### 6.4 Kotlin 使用

```kotlin
val layout = findViewById<FoldPadWindowLayout>(R.id.fold_pad_window)
layout.setContentView(contentView)
layout.setSidebarContent(menuView)
```

## 7. 打包 AAR

执行：
```
./gradlew :foldwindow:assembleRelease
```

生成路径（默认）：
```
foldwindow/build/outputs/aar/foldwindow-release.aar
```

## 8. 可调参数（当前版本）

如需调整，请在 `FoldPadWindowLayout.java` 中修改常量：
- `DEFAULT_SIDEBAR_WIDTH_PERCENT`（默认菜单宽度）
- `MIN_SIDEBAR_WIDTH_PERCENT` / `MAX_SIDEBAR_WIDTH_PERCENT`（拖拽范围）
- `MINI_HEIGHT_PERCENT`（小窗高度比例）
- `ANIM_DURATION_MS`（动画时长）
- `mMiniCornerRadius`（圆角半径）

若需要通过外部配置，可后续新增 setter。

## 9. 注意事项

- 小窗状态下自动隐藏菜单按钮，避免误触
- 小窗状态自动关闭菜单
- 菜单挤压效果不会在小窗状态生效（避免拖拽时错位）
- 建议在 Pad/折叠屏使用，否则小屏拖拽空间不足

## 10. 无障碍服务原理与适配步骤

### 10.1 原理说明（简单版）

无障碍服务就像“读屏的小伙伴”。  
它需要知道：
- **哪个控件可以被点击**
- **控件叫什么名字**
- **当前是什么状态**

如果我们只用手指滑动，但不告诉系统“我点了一下”，读屏就会“看不到”这次点击。

### 10.2 适配步骤（本组件已做）

1. **给可交互控件加说明文字**
   - `setContentDescription("打开或关闭菜单")`
   - 读屏会念出这段话

2. **触摸结束时调用 `performClick()`**
   - 让系统知道“这个控件被点了”
   - 解决 Lint 提示：`setOnTouchListener but not performClick`

3. **重写 `performClick()`**
   - 保证无障碍能收到点击事件

4. **需要时添加状态提示**
   - 比如“菜单已展开”“已切换小窗”
   - 可通过 `announceForAccessibility()` 主动播报

### 10.3 如果你要扩展的建议

- **按钮可聚焦**：确保 `setFocusable(true)`
- **可读状态**：按钮文字/描述同步状态（如：`菜单已打开`）
- **拖拽条提示**：在拖拽开始/结束时播报提示语

### 10.4 本组件当前已覆盖的点

- MENU / MINI / FULL 按钮有 `contentDescription`
- 侧边栏拖拽条有 `contentDescription`
- 触摸结束会调用 `performClick()`
- 组件实现了 `performClick()`，便于无障碍识别
